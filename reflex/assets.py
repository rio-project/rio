from __future__ import annotations

import hashlib
import io
import secrets
from pathlib import Path
from typing import Optional, Union, Tuple

import aiohttp
from PIL.Image import Image

from . import app_server
from .common import Url, ImageLike
from .self_serializing import SelfSerializing

# Random bytes added during hashing to make any internal values extremely
# difficult to guess
_HASH_SALT = secrets.token_bytes(32)


def _securely_hash_bytes_changes_between_runs(data: bytes) -> bytes:
    """
    Returns an undefined, cryptographically secure hash of the given bytes. A
    random value is added to the hash to make it difficult to guess the
    original value. This random value is the same for all hashes generated by
    this function during the same run of the program, but changes between runs.
    """

    hasher = hashlib.sha256()
    hasher.update(_HASH_SALT)
    hasher.update(data)
    return hasher.digest()


class HostedAsset(SelfSerializing):
    def __init__(
        self,
        data: Union[bytes, Path, Url],
        media_type: Optional[str] = None,
    ):
        # The MIME type of the asset
        self.media_type = media_type

        # The asset's data. This can either be a bytes object, or a path to a
        # file containing the asset's data. The file must exist for the duration
        # of the asset's lifetime.
        self.data = data

        if isinstance(data, Path):
            assert data.exists(), f"Asset file {data} does not exist"
    
    @property
    def secret_id(self) -> str:
        # The asset's id both uniquely identifies the asset, and is used as part
        # of the asset's URL.
        #
        # It is derived from the data, so that if the same file is to be hosted
        # multiple times only one instance is actually stored. Furthermore, this
        # allows the client to cache the asset efficiently, since the URL is
        # always the same.
        try:
            return self._secret_id
        except AttributeError:
            pass

        if isinstance(self.data, bytes):
            # TODO: Consider only hashing part of the data + media type + size
            # rather than processing everything
            secret_id_prefix = "b-"
            secret_id_str = _securely_hash_bytes_changes_between_runs(self.data).hex()
        elif isinstance(self.data, Path):
            secret_id_prefix = "f-"
            secret_id_str = _securely_hash_bytes_changes_between_runs(
                str(self.data.resolve()).encode("utf-8")
            ).hex()
        else:
            secret_id_prefix = "u-"
            secret_id_str = self.data

        self._secret_id = secret_id_prefix + secret_id_str
        return self._secret_id
    
    def _serialize(self, server: app_server.AppServer) -> str:
        if isinstance(self.data, Url):
            return self.data
        
        server.weakly_host_asset(self)
        return self.url()

    def url(self, server_external_url: Optional[str] = None) -> str:
        """
        Returns the URL at which the asset can be accessed. If
        `server_external_url` is passed the result will be an absolute URL. If
        not, a relative URL is returned instead.
        """
        if isinstance(self.data, Url):
            return self.data

        relative_url = f"/reflex/asset/temp-{self.secret_id}"

        if server_external_url is None:
            return relative_url
        else:
            # TODO document this and/or enfoce it in the `AppServer` class already
            assert not server_external_url.endswith(
                "/"
            ), "server_external_url must not end with a slash"
            return server_external_url + relative_url
    
    async def _try_fetch_as_blob(self) -> Tuple[bytes, Optional[str]]:
        """
        Try to fetch the image as blob & media type. Raises a `ValueError` if
        fetching fails.
        """
        # URL
        if isinstance(self.data, Url):
            async with aiohttp.ClientSession() as session:
                async with session.get(self.data) as response:
                    return await response.read(), response.content_type

        # Straight bytes
        if isinstance(self.data, bytes):
            return self.data, self.media_type

        # File
        return self.data.read_bytes(), self.media_type

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, HostedAsset):
            return NotImplemented

        if self.media_type != other.media_type:
            return False

        return self.secret_id == other.secret_id


class ImageAsset(HostedAsset):
    def __init__(
        self,
        image: ImageLike,
        media_type: Optional[str] = None,
    ):
        if isinstance(image, Image):
            file = io.BytesIO()
            image.save(file, format="PNG")
            image = file.getvalue()
            media_type = "image/png"

        super().__init__(image, media_type)
